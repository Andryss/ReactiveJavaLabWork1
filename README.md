# Реактивная Java

## Текст задания лабораторной работы 1

Предметная область: космические корабли.

1. Написать для согласованной предметной области как минимум 3 базовых класса и генераторы объектов. Генератор должен уметь создавать указанное количество различных объектов соответствующего класса со случайными (но при этом валидными) характеристиками. Класс, представляющий собой массовый объект должен обязательно содержать поля следующих типов:
   - один из примитивов (int, long, double)
   - String
   - дата/время (LocalDate, LocalTime, ...)
   - enum
   - record
   - массив или коллекция
   
   Остальные поля - произвольные, какие нужны для предметной области. 
   Два оставшихся класса должны представлять собой дополнительные атрибуты и характеристики массового класса.

2. С помощью генератора создать коллекцию объектов.

3. Написать код, реализующий расчет согласованных агрегированных статических данных тремя способами:
   3.1. Итерационным циклом по коллекции
   3.2. Конвейером с помощью Stream API на базе коллекторов из стандартной библиотеки
   3.3. Конвейером с помощью собственного коллектора.

4. Для каждого варианта измерить время выполнения, зафиксировав моменты начала и окончания расчета для количества элементов в коллекции - 5000, 50000 и 250000. Время измерять с помощью методов класса System или Instant.

## Текст задания лабораторной работы 2

1. В один из методов, использовавшийся для сбора статистики, добавить возможность задать задержку, имитирующую задержку получения результата, например из базы данных. К примеру, был метод getName(), в который нужно добавить параметр getName(long delay)

2. Заменить последовательный стрим, собирающий статистику из лабораторной №1, на параллельный. Поменять итоговую коллекцию, где собирается результат, на соответствующую потокобезопасную. Измерить производительность для разного количества элементов с дополнительной задержкой и без задержки. Для случаев с задержкой и без - найти количество элементов, при котором сбор статистики последовательным и параллельным стримами дают одинаковую скорость выполнения.

3. Оптимизировать параллельный сбор статистики, реализовав собственный Spliterator. Измерить производительность своего варианта.

4. Измерения производительности выполнять с помощью фреймворка JMH.

## Текст задания лабораторной работы 3

1. Реализовать подсчет статистики, аналогичный использованному в лабораторной работе №2, с помощью реактивных потоков Observable на RxJava. Должна обеспечиваться многопоточная асинхронная обработка с использованием Scheduler.

2. Провести сравнение производительности обработки 500 и 2000 элементов с включенной задержкой для параллельных потоков (из лабы 2) и для реактивных потоков. Необходимо добиться, чтобы производительность реактивных потоков была такой же или лучше, чем при использовании параллельных потоков.

3. Отключить зaдержку при создании элементов. Реализовать собственный Subscriber для подсчета статистики, регулирующий скорость поступления элементов из потока. Генерацию элементов с поддержкой backpressure производить асинхронно с помощью Flowable. Убедиться, что при большом количестве элементов (больше 100000) система работает стабильно и без задержек.

## Авторы

- [Кривошеев Андрей](https://github.com/Andryss)
- [Тучин Артем](https://github.com/artem00475)
